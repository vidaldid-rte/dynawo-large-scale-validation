#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# adapted from the dynaflow pipeline
#
#
# extract_powerflow_values.py: Once a case has been run in Hades and OpenLoadFlow.
# this script extracts all relevant values of the resulting steady state, for the
# purpose of comparing both solutions in later analysis. In the output, the device
# types, IDs.
#
# On input, the script takes a directory containing both an Hades and a DynaFlow
# power-flow case, both of which have already been run. For now, the following dir
# structure is assumed:
#
#   TODO: UPDATE
#   CASE_DIR/
#   ├── EntreeHades.xml
#   └── EntreeOlf.xiidm
# (Plus, of course, all the *output* files and dirs generated by Hades and Dynawo)
#
#
# On output, the script generates one main output file and (possibly) two error files:
#
#   CASE_DIR/
#   ├── pfsolution_HO.csv
#   ├── elements_not_in_caseHades.csv
#   └── elements_not_in_caseOlf.csv
#
# The output file has the following columns:
#
#    ["ID", "ELEMENT_TYPE", "VAR", "VOLT_LEVEL", "VALUE_A", "VALUE_B"]
#
# where we use the VAR names used in Dynawo.
#

import os
import math
import sys
import pandas as pd
from lxml import etree
from collections import namedtuple

sys.path.insert(
    1, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
)

OLF_SOLUTION = "olf.xiidm"
HDS_INPUT = "entreeHades.xml"
HDS_SOLUTION = "out.xml"
OUTPUT_FILE = "pfsolution_HO.csv"
ERRORS_HADES_FILE = "elements_not_in_Hades.csv"
ERRORS_OLF_FILE = "elements_not_in_caseOlf.csv"
HDS_INACT_BUS = "999999.000000000000000"  # "magic" value used in Hades
HDS_INACT_SHUNT = "999999"
HDS_INACT_SHUNT2 = "0"  # we found a few cases where Hades uses this instead!
ZEROPQ_TOL = 1.0e-5  # inactivity detection: flows below this (in MW) considered zero

# named tuples
Branch_info = namedtuple("Branch_info", ["type", "bus1", "bus2"])
Hds_gridinfo = namedtuple(
    "Hds_gridinfo",
    ["branch_sides", "tap2xfmr", "pstap2xfmr", "shunt2busname", "svc_qfixed"],
)
Hds_branch_side = namedtuple("Hds_branch_side", ["bus1", "bus2"])

verbose = True


def main():

    if len(sys.argv) != 2:
        print(f"\nUsage: {sys.argv[0]} case_dir\n")
        return 2
    case_dir = sys.argv[1]

    if verbose:
        print(f"Extracting solution values for case: {case_dir}")

    hades_input = os.path.join(case_dir, HDS_INPUT)
    hades_output = os.path.join(case_dir, HDS_SOLUTION)
    olf_file = os.path.join(case_dir, OLF_SOLUTION)
    check_inputfiles(case_dir, hades_output, olf_file)


    # Extract the solution values from Dynawo results
    df_olf, vl_nomV, branch_info = extract_iidm_solution(olf_file)

    # Extract the solution values from Hades results
    df_hds = extract_hades_solution(
        hades_input, hades_output, vl_nomV, branch_info
    )

    # Merge, sort, and save
    # TODO - save missing buses and find differences
    save_extracted_values(df_hds, df_olf, os.path.join(case_dir,OUTPUT_FILE))
    save_nonmatching_elements(
        df_hds, df_olf, os.path.join(case_dir, ERRORS_HADES_FILE), os.path.join(case_dir,ERRORS_OLF_FILE)
    )

    return 0

def check_inputfiles(case_dir, solution_1, solution_2):
    if not os.path.isdir(case_dir):
        raise ValueError(f"case directory {case_dir} not found")

    if not (
        os.path.isfile(solution_1) and os.path.isfile(solution_2)
    ):
        raise ValueError(f"the expected PF solution files are missing in {case_dir}\n")


def extract_iidm_solution(iidm_output):
    """Read all output and return a dataframe. Create vl_nomv & branches"""
    tree = etree.parse(iidm_output)

    root = tree.getroot()

    vl_nomv = dict()
    branches = dict()

    # We'll be using a dataframe, for sorting
    column_list = ["ID", "ELEMENT_TYPE", "VOLT_LEVEL", "VAR", "VALUE_OLF"]
    data = []
    print("   found in IIDM file: ", end="")
    # Buses: get V & angle
    extract_iidm_buses(root, data, vl_nomv)
    # Lines: p & q flows
    extract_iidm_lines(root, data, vl_nomv, branches)
    # Transformers and phase shifters: p & q flows
    extract_iidm_xfmrs(root, data, vl_nomv, branches)

    # Aggregate bus injections (loads, generators, shunts, VSCs)
    extract_iidm_bus_inj(root, data, vl_nomv)

    return pd.DataFrame(data, columns=column_list), vl_nomv, branches


def extract_iidm_buses(root, data, vl_nomv):
    """Read V & angles, and update data. Also update the vl_nomv dict"""
    ctr = 0
    ign = 0
    for bus in root.iterfind(".//iidm:bus", root.nsmap):
        bus_name = bus.get("id")
        v = bus.get("v")
        angle = bus.get("angle")
        # build the voltlevel dict *before* skipping inactive buses
        vl_nomv[bus_name] = float(bus.getparent().getparent().get("nominalV"))
        # skip inactive buses
        if (v == "0" or v is None) and (angle == "0" or angle is None) :
            continue
        if bus_name is None:
            # unnamed bus in node breaker mode cannot be matched with Hades so they are ignored
            ign += 1
            continue
        volt_level = vl_nomv[bus_name]
        data.append([bus_name, "bus", volt_level, "v", float(v)])
        data.append([bus_name, "bus", volt_level, "angle", float(angle)])
        ctr += 1
    print(f" {ctr:5d} buses", end="")
    print(f" {ign:5d} ignored buses", end="")

def floatOrZero(v):
    return 0 if v is None else float(v)

def extract_iidm_lines(root, data, vl_nomv, branches):
    """Read line flows, and update data. Also update branches dict"""
    ctr = 0
    for line in root.iterfind("./iidm:line", root.nsmap):
        line_name = line.get("id")
        p1 = floatOrZero(line.get("p1"))
        q1 = floatOrZero(line.get("q1"))
        p2 = floatOrZero(line.get("p2"))
        q2 = floatOrZero(line.get("q2"))
        # build the branches dict *before* skipping inactive lines
        branches[line_name] = Branch_info(
            type="line",
            bus1=line.get("connectableBus1"),
            bus2=line.get("connectableBus2"),
        )
        # skip inactive lines (beware threshold effect when comparing to the other case)
        if (
            abs(p1) < ZEROPQ_TOL
            and abs(q1) < ZEROPQ_TOL
            and abs(p2) < ZEROPQ_TOL
            and abs(q2) < ZEROPQ_TOL
        ):
            continue
        volt_level = vl_nomv[line.get("connectableBus1")]
        element_type = branches[line_name].type
        data.append([line_name, element_type, volt_level, "p1", p1])
        data.append([line_name, element_type, volt_level, "q1", q1])
        data.append([line_name, element_type, volt_level, "p2", p2])
        data.append([line_name, element_type, volt_level, "q2", q2])
        ctr += 1
    print(f" {ctr:5d} lines", end="")


def extract_iidm_xfmrs(root, data, vl_nomv, branches):
    """Read xfmr flows & taps, and update data. Also update branches dict, if case_A"""
    ctr, psctr = [0, 0]
    for xfmr in root.iterfind(".//iidm:twoWindingsTransformer", root.nsmap):
        xfmr_name = xfmr.get("id")
        p1 = floatOrZero(xfmr.get("p1"))
        q1 = floatOrZero(xfmr.get("q1"))
        p2 = floatOrZero(xfmr.get("p2"))
        q2 = floatOrZero(xfmr.get("q2"))
        tap = xfmr.find("./iidm:ratioTapChanger", root.nsmap)
        ps_tap = xfmr.find("./iidm:phaseTapChanger", root.nsmap)
        # build branches dict *before* skipping inactive transformers
        if ps_tap is not None:
            branches[xfmr_name] = Branch_info(
                type="psxfmr",
                bus1=xfmr.get("connectableBus1"),
                bus2=xfmr.get("connectableBus2"),
            )
        else:
            branches[xfmr_name] = Branch_info(
                type="xfmr",
                bus1=xfmr.get("connectableBus1"),
                bus2=xfmr.get("connectableBus2"),
            )
        # skip inactive xfmrs (beware threshold effect when comparing to the other case)
        if (
            abs(p1) < ZEROPQ_TOL
            and abs(q1) < ZEROPQ_TOL
            and abs(p2) < ZEROPQ_TOL
            and abs(q2) < ZEROPQ_TOL
        ):
            continue
        volt_level = vl_nomv[xfmr.get("connectableBus2")]  # side 2 assumed always HV
        data.append([xfmr_name, branches[xfmr_name].type, volt_level, "p1", p1])
        data.append([xfmr_name, branches[xfmr_name].type, volt_level, "q1", q1])
        data.append([xfmr_name, branches[xfmr_name].type, volt_level, "p2", p2])
        data.append([xfmr_name, branches[xfmr_name].type, volt_level, "q2", q2])
        # transformer taps
        if tap is not None:
            data.append(
                [
                    xfmr_name,
                    branches[xfmr_name].type,
                    volt_level,
                    "tap",
                    int(tap.get("tapPosition")),
                ]
            )
        # phase-shifter taps
        if ps_tap is not None:
            data.append(
                [
                    xfmr_name,
                    branches[xfmr_name].type,
                    volt_level,
                    "pstap",
                    int(ps_tap.get("tapPosition")),
                ]
            )
        # counters
        if branches[xfmr_name].type == "psxfmr":
            psctr += 1
        else:
            ctr += 1
    print(f" {ctr:5d} xfmrs", end="")
    print(f" {psctr:3d} psxfmrs", end="")


def extract_iidm_bus_inj(root, data, vl_nomv):
    """Aggregate injections (loads, gens, shunts, VSCs) by bus, and update data."""
    # Since a voltage level may contain more than one bus, it is easier to keep the
    # aggregate injections in dicts indexed by bus, and then output at the end.
    p_inj = dict()
    q_inj = dict()
    injection_types = (
        "load",
        "generator",
        "shunt",
        "vscConverterStation",
        "staticVarCompensator",
    )
    for vl in root.iterfind(".//iidm:voltageLevel", root.nsmap):
        injection_elements = [
            e for e in vl if etree.QName(e.tag).localname in injection_types
        ]
        for element in injection_elements:
            bus_name = element.get("bus")
            if bus_name is not None:
                if element.get("p") is not None:
                    p_inj[bus_name] = p_inj.get(bus_name, 0.0) + float(element.get("p"))
                if element.get("q") is not None:
                    q_inj[bus_name] = q_inj.get(bus_name, 0.0) + float(element.get("q"))
    # update data
    for bus_name in p_inj:
        p = p_inj[bus_name]
        if abs(p) > ZEROPQ_TOL:
            data.append([bus_name, "bus", vl_nomv[bus_name], "p", p])
    for bus_name in q_inj:
        q = q_inj[bus_name]
        if abs(q) > ZEROPQ_TOL:
            data.append([bus_name, "bus", vl_nomv[bus_name], "q", q])
    print("                         ", end="")  # Hades has extra output here
    print(f" {len(p_inj):5d} P-injections", end="")
    print(f" {len(q_inj):5d} Q-injections")


def extract_hades_solution(
    hades_input, hades_output, vl_nomv, dwo_branches
):
    """Read all output and return a dataframe."""
    # We'll be using a dataframe, for sorting
    column_list = ["ID", "ELEMENT_TYPE", "VAR", "VALUE_HADES"]
    data = []
    # Some structural info is not in the output; we need to get it from the Hades input
    gridinfo = extract_hds_gridinfo(hades_input)
    # And the rest will be obtained from the output file
    tree = etree.parse(hades_output)
    root = tree.getroot()

    print("   found in Hades file:", end="")
    # Buses: get V & angle
    extract_hds_buses(vl_nomv, root, data)
    # Branches (line/xfmr/psxfmr): p & q flows and xfmr taps
    extract_hds_branches(dwo_branches, gridinfo, root, data)
    # Aggregate bus injections (loads, generators, shunts, VSCs)
    extract_hds_bus_inj(gridinfo, root, data)
    return pd.DataFrame(data, columns=column_list)


def extract_hds_gridinfo(hades_input):
    """Read info that's only available in the input file (branch buses; xfmr taps)."""

    tree = etree.parse(hades_input)
    root = tree.getroot()
    reseau = root.find("./reseau", root.nsmap)
    # an auxiliary dict that maps "num" to "nom"
    buses = dict()
    donneesNoeuds = reseau.find("./donneesNoeuds", root.nsmap)
    for bus in donneesNoeuds.iterfind("./noeud", root.nsmap):
        buses[bus.get("num")] = bus.get("nom")
    buses["-1"] = "DISCONNECTED"
    # Build a dict that maps branch names to their bus1 and bus2 names
    branch_sides = dict()
    donneesQuadripoles = reseau.find("./donneesQuadripoles", root.nsmap)
    for branch in donneesQuadripoles.iterfind("./quadripole", root.nsmap):
        branch_sides[branch.get("nom")] = Hds_branch_side(
            bus1=buses[branch.get("nor")], bus2=buses[branch.get("nex")]
        )
    # Build a dict that maps "regleur" IDs to their transformer's name AND a dict
    # that maps "dephaseur" IDs to their transformer's name
    tap2xfmr = dict()
    pstap2xfmr = dict()
    for branch in donneesQuadripoles.iterfind("./quadripole", root.nsmap):
        tap_ID = branch.get("ptrregleur")
        if tap_ID != "0" and tap_ID is not None:
            tap2xfmr[tap_ID] = branch.get("nom")
        pstap_ID = branch.get("ptrdepha")
        if pstap_ID != "0" and pstap_ID is not None:
            pstap2xfmr[pstap_ID] = branch.get("nom")
    # Build a dict that maps shunt IDs to their respective bus names
    shunt2busname = dict()
    donneesShunts = reseau.find("./donneesShunts", root.nsmap)
    for shunt in donneesShunts.iterfind("./shunt", root.nsmap):
        bus_num = shunt.get("noeud")
        if bus_num != "-1":
            shunt2busname[shunt.get("num")] = buses[bus_num]
    # Build a dict that maps bus names to total QFixed originated from SVCs (if any)
    svc_qfixed = dict()
    donneesCsprs = reseau.find("./donneesCsprs", root.nsmap)
    for cspr in donneesCsprs.iterfind("./cspr", root.nsmap):
        bus_num = cspr.get("conbus")
        if bus_num != "-1":
            svc_qfixed[buses[bus_num]] = svc_qfixed.get(buses[bus_num], 0) + float(
                cspr.get("shunt")
            )
    return Hds_gridinfo(
        branch_sides=branch_sides,
        tap2xfmr=tap2xfmr,
        pstap2xfmr=pstap2xfmr,
        shunt2busname=shunt2busname,
        svc_qfixed=svc_qfixed,
    )


def extract_hds_buses(vl_nomv, root, data):
    """Read V & angles, and update data."""
    reseau = root.find("./reseau", root.nsmap)
    donneesNoeuds = reseau.find("./donneesNoeuds", root.nsmap)
    ctr = 0
    ign = 0
    for bus in donneesNoeuds.iterfind("./noeud", root.nsmap):
        bus_name = bus.get("nom")
        v = bus[0].get("v")
        angle = bus[0].get("ph")
        if v == HDS_INACT_BUS and angle == HDS_INACT_BUS:
            continue  # skip inactive buses
        if bus_name in vl_nomv:
            data.append([bus_name, "bus", "v", float(v) * vl_nomv[bus_name] / 100])
            data.append([bus_name, "bus", "angle", float(angle) * 180 / math.pi])
            ctr += 1
        else:
            ign += 1
    print(f" {ctr:5d} buses", end="")
    print(f" {ign:5d} ignored buses", end="")


def extract_hds_branches(dwo_branches, gridinfo, root, data):
    """Read branch flows (incl. xfmr taps), and update data."""
    # First we extract tap and phase-shifter tap values (used in the loop below)
    taps, pstaps = extract_hds_taps(root, gridinfo)
    # And now we extract the branch (quadripole) data
    hds_branch_sides = gridinfo.branch_sides  # for checking side convention below
    lctr, xctr, psctr, bad_ctr = [0, 0, 0, 0]
    reseau = root.find("./reseau", root.nsmap)
    donneesQuadripoles = reseau.find("./donneesQuadripoles", root.nsmap)
    for quadrip in donneesQuadripoles.iterfind("./quadripole", root.nsmap):
        quadrip_name = quadrip.get("nom")
        p1 = float(quadrip[0].get("por"))
        q1 = float(quadrip[0].get("qor"))
        p2 = float(quadrip[0].get("pex"))
        q2 = float(quadrip[0].get("qex"))
        # magic number 999999 is used for disconnected branches
        if p1 > 999_990:
            p1 = 0.0
        if q1 > 999_990:
            q1 = 0.0
        if p2 > 999_990:
            p2 = 0.0
        if q2 > 999_990:
            q2 = 0.0
        # skip inactive lines
        if (
            abs(p1) < ZEROPQ_TOL
            and abs(q1) < ZEROPQ_TOL
            and abs(p2) < ZEROPQ_TOL
            and abs(q2) < ZEROPQ_TOL
        ):
            continue
        # find out whether it is a line/xfmr/psxfmr by looking it up in Dynawo case
        dwo_branch_info = dwo_branches.get(quadrip_name)
        if dwo_branch_info is not None:
            element_type = dwo_branch_info.type
            # and if side-labeling convention is reversed, fix it
            if hds_branch_sides[quadrip_name].bus1 == dwo_branch_info.bus2:
                p1, p2 = (p2, p1)
                q1, q2 = (q2, q1)
        else:
            element_type = "QUADRIPOLE_NOT_IN_DWO"
        # collect the data
        data.append([quadrip_name, element_type, "p1", p1])
        data.append([quadrip_name, element_type, "q1", q1])
        data.append([quadrip_name, element_type, "p2", p2])
        data.append([quadrip_name, element_type, "q2", q2])
        tap_value = taps.get(quadrip_name)
        if tap_value is not None:
            data.append([quadrip_name, element_type, "tap", tap_value])
        pstap_value = pstaps.get(quadrip_name)
        if pstap_value is not None:
            data.append([quadrip_name, element_type, "pstap", pstap_value])
        # counters
        if element_type == "line":
            lctr += 1
        elif element_type == "xfmr":
            xctr += 1
        elif element_type == "psxfmr":
            psctr += 1
        else:
            bad_ctr += 1
    print(
        f" {lctr:5d} lines {xctr:5d} xfmrs {psctr:3d} psxfmrs"
        f" ({bad_ctr} quadrip. not in Dwo) ",
        end=""
    )


def extract_hds_taps(root, gridinfo):
    """Read tap values and return them in two dicts indexed by name (taps, pstaps)."""
    # First transformer taps
    tap2xfmr = gridinfo.tap2xfmr
    taps = dict()
    reseau = root.find("./reseau", root.nsmap)
    donneesRegleurs = reseau.find("./donneesRegleurs", root.nsmap)
    for regleur in donneesRegleurs.iterfind("./regleur", root.nsmap):
        quadrip_name = tap2xfmr.get(regleur.get("num"))
        if quadrip_name is None:
            raise ValueError(
                f"in Hades output file: regleur {regleur.get('num')}"
                "  has no associated transformer!"
            )
        taps[quadrip_name] = int(regleur.find("./variables", root.nsmap).get("plot"))
    # Now phase-shifter taps
    pstap2xfmr = gridinfo.pstap2xfmr
    pstaps = dict()
    donneesDephaseurs = reseau.find("./donneesDephaseurs", root.nsmap)
    for dephaseur in donneesDephaseurs.iterfind("./dephaseur", root.nsmap):
        quadrip_name = pstap2xfmr.get(dephaseur.get("num"))
        if quadrip_name is None:
            raise ValueError(
                f"in Hades output file: dephaseur {dephaseur.get('num')}"
                "  has no associated transformer!"
            )
        pstaps[quadrip_name] = int(
            dephaseur.find("./variables", root.nsmap).get("plot")
        )
    return taps, pstaps


def extract_hds_bus_inj(gridinfo, root, data):
    """Aggregate injections (loads, gens, shunts, VSCs) by bus, and update data."""
    # Conveniently, Hades already provides the bus injections in the bus output
    # section Alas, Hades has two bugs:
    #   1) these injections don't include shunts!
    #   2) these injections don't include the fixed part of Static Var Compensators
    # So we'll correct for these two things here.
    # First collect shunt's Q injections
    shunt2busname = gridinfo.shunt2busname
    shunt_qcorr = dict()
    reseau = root.find("./reseau", root.nsmap)
    donneesShunts = reseau.find("./donneesShunts", root.nsmap)
    for shunt in donneesShunts.iterfind("./shunt", root.nsmap):
        shunt_vars = shunt.find("./variables", root.nsmap)
        q = shunt_vars.get("q")
        if q in (HDS_INACT_SHUNT, HDS_INACT_SHUNT2):
            continue  # skip inactive shunts
        bus_name = shunt2busname[shunt.get("num")]
        shunt_qcorr[bus_name] = shunt_qcorr.get(bus_name, 0.0) - float(q)
    # The fixed part of SVCs will need to be calculated inside the loop below
    svc_qfixed = gridinfo.svc_qfixed
    # Finally, we collect all the injection data, making the appropriate corrections
    pctr, qctr = [0, 0]
    donneesNoeuds = reseau.find("./donneesNoeuds", root.nsmap)
    for bus in donneesNoeuds.iterfind("./noeud", root.nsmap):
        bus_name = bus.get("nom")
        bus_vars = bus.find("./variables", root.nsmap)
        if bus_vars.get("v") == HDS_INACT_BUS and bus_vars.get("ph") == HDS_INACT_BUS:
            continue  # skip inactive buses
        # update data (note the opposite sign convention w.r.t. Dynawo)
        p = -float(bus_vars.get("injact"))
        if abs(p) > ZEROPQ_TOL:
            data.append([bus_name, "bus", "p", p])
            pctr += 1
        # SVC's fixed shunt Q values are calculated here because we need the bus V
        q = (
            -float(bus_vars.get("injrea"))
            + shunt_qcorr.get(bus_name, 0)
            - (svc_qfixed.get(bus_name, 0) * float(bus_vars.get("v")) ** 2)
        )
        if abs(q) > ZEROPQ_TOL:
            data.append([bus_name, "bus", "q", q])
            qctr += 1
    print(f" {pctr:5d} P-injections", end="")
    print(f" {qctr:5d} Q-injections")


def save_extracted_values(df_a, df_b, output_file):
    """Save the values for all elements that are matched in both outputs."""
    # Merge (inner join) the two dataframes, checking for duplicates (just in case)
    key_fields = ["ELEMENT_TYPE", "ID", "VAR"]
    df = pd.merge(
        df_a,
        df_b,
        how="inner",
        on=key_fields,
        validate="one_to_one",
    )
    # Print some summaries
    print("   common to both files:", end="")
    bus_angles = (df["ELEMENT_TYPE"] == "bus") & (df["VAR"] == "angle")
    print(f" {len(df.loc[bus_angles]):5d} buses", end="")
    lines_p1 = (df["ELEMENT_TYPE"] == "line") & (df["VAR"] == "p1")
    print(f" {len(df.loc[lines_p1]):5d} lines", end="")
    xfmr_p1 = (df["ELEMENT_TYPE"] == "xfmr") & (df["VAR"] == "p1")
    print(f" {len(df.loc[xfmr_p1]):5d} xfmrs", end="")
    psxfmr_p1 = (df["ELEMENT_TYPE"] == "psxfmr") & (df["VAR"] == "p1")
    print(f" {len(df.loc[psxfmr_p1]):3d} psxfmrs")
    # Adjust the bus angles to those of solution A
    swing_idx = df.loc[bus_angles, "VALUE_OLF"].abs().idxmin()
    angle_offset = df.at[swing_idx, "VALUE_HADES"] - df.at[swing_idx, "VALUE_OLF"]
    df.loc[bus_angles, "VALUE_HADES"] -= angle_offset
    print(f'   (angle offset adjusted; zero angle at bus: {df.at[swing_idx, "ID"]})')
    # Sort and save to file
    sort_order = [True, True, True]
    tempcol = df.pop("VOLT_LEVEL")
    df.insert(2, "VOLT_LEVEL", tempcol)
    df.sort_values(
        by=key_fields, ascending=sort_order, inplace=True, na_position="first"
    )
    df.to_csv(output_file, index=False, sep=";", encoding="utf-8")
    print(f"Saved output to file: {output_file}... ")


def save_nonmatching_elements(df_hds, df_olf, errors_hds_file, errors_olf_file):
    """Save the elements that did not match. Some may be due to threshold flows."""
    key_fields = ["ELEMENT_TYPE", "ID", "VAR"]
    # Output the diffs. Newer versions of Pandas support df.compare(), but here we do
    # it in a more backwards-compatible way.
    set_A = frozenset(df_hds["ID"].add(df_hds["ELEMENT_TYPE"]))
    set_B = frozenset(df_olf["ID"].add(df_olf["ELEMENT_TYPE"]))
    elements_not_in_A = list(set_B - set_A)
    elements_not_in_B = list(set_A - set_B)
    if len(elements_not_in_A) != 0:
        df_not_in_A = df_olf.loc[
            (df_olf["ID"] + df_olf["ELEMENT_TYPE"]).isin(elements_not_in_A)
        ]
        df_not_in_A.sort_values(by=key_fields, ascending=[True, True, True]).to_csv(
            errors_hds_file, index=False, sep=";", encoding="utf-8"
        )
        print(
            f"{len(elements_not_in_A)} elements from case OLF not in case Hades "
            f"saved in file: {errors_hds_file}"
        )
    if len(elements_not_in_B) != 0:
        df_not_in_B = df_hds.loc[
            (df_hds["ID"] + df_hds["ELEMENT_TYPE"]).isin(elements_not_in_B)
        ]
        df_not_in_B.sort_values(by=key_fields, ascending=[True, True, True]).to_csv(
            errors_olf_file, index=False, sep=";", encoding="utf-8"
        )
        print(
            f"{len(elements_not_in_B)} elements from Hades not in case OLF "
            f"saved in file: {errors_olf_file}"
        )


if __name__ == "__main__":
    sys.exit(main())
